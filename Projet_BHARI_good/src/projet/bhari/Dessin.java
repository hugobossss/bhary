/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package projet.bhari;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.Timer;

/**
 *
 * @author hburlon
 */
public class Dessin extends javax.swing.JFrame implements ActionListener, KeyListener {

    /**
     * Creates new form Dessin
    */
    private BufferedImage buffer;
    private Graphics2D contexteBuffer;
    private Timer timer;
    //private JLabel jLabel1;
    //private ActionEvent event;
    private Plateau p;
   // private Graphics2D contexteBufferMap;
    private static int TILE_WIDTH = 32;
    private static int TILE_HEIGHT = 32;
    private static int TILES_PER_ROW = 16;
    private static int TILES_PER_COL = 16;
    private ArrayList<Joueur> ListeJoueurReseau;
    private int LimiteX = 840;
    private int LimiteY = 608;
    public static JeuBHARY instance;
    public Dessin(JeuBHARY instance) {
       initComponents();
        this.instance = instance;
        
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.addKeyListener(this);

        // Creation du buffer pour l'affichage du jeu et recuperation du contexte graphique
        this.buffer = new BufferedImage(this.jLabel1.getWidth(), this.jLabel1.getHeight(), BufferedImage.TYPE_INT_ARGB);
        this.jLabel1.setIcon(new ImageIcon(buffer));
        this.contexteBuffer = this.buffer.createGraphics();

        // Creation du Timer qui appelle this.actionPerformed() tous les 40 ms
        this.timer = new Timer(40,  this);
        this.timer.start();
             
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();

        jLabel1.setText("                                                                                                                                 jLabel1");

        jLabel2.setText("jLabel2");

        jLabel3.setText("jLabel3");

        jLabel4.setText("jLabel4");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 810, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addContainerGap(148, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(56, 56, 56)
                .addComponent(jLabel2)
                .addGap(26, 26, 26)
                .addComponent(jLabel3)
                .addGap(31, 31, 31)
                .addComponent(jLabel4)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 608, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Dessin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Dessin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Dessin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Dessin.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Dessin(instance).setVisible(true);
                
            }
        });
    }
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    // End of variables declaration//GEN-END:variables

   //public  ProjetBHARI instance; 
   boolean event = false;
   boolean event2=false;
   public  void actionPerformed (ActionEvent e){  
        // System.out.println(instance.J.getCoordonneesJoueur());
       
      // if(event2==false){
        if((Dessin.instance.sql.gameStarted(4)) && (event==false)){
            //System.out.println("gameStarted(1)"); 
            this.ListeJoueurReseau= new ArrayList<Joueur>();
            this.ListeJoueurReseau = Dessin.instance.sql.miseAJourListeJoueurReseau(Dessin.instance.J.getJoueurName()); //this.ListeJoueurReseau = instance.sql.miseAJourListeJoueurReseau(instance.J.getJoueurName());
           // System.out.println("miseAJourListeJoueurReseau");
           System.out.println("le fuuuuuuuuuuuuuuuun");
           System.out.println(this.ListeJoueurReseau.get(0).getIcon());
            this.p = new Plateau(this.ListeJoueurReseau,this.LimiteX,this.LimiteY);
           // System.out.println("Plateau"); 
            p.setGauche(true);// fonction random 
           // System.out.println("setGauche"); 
            event = true; 
            System.out.println(this.ListeJoueurReseau.get(0).getCoordonneesJoueur());
        }
        
        if(event){
            
            Dessin.instance.sql.afficherJoueurs(Dessin.instance.J); //
            this.ListeJoueurReseau =Dessin.instance.sql.miseAJourListeJoueurReseau(Dessin.instance.J.getJoueurName()); //
            System.out.println("this.ListeJoueurReseau.get(0).getCoordonneesJoueur()");
            System.out.println(this.ListeJoueurReseau.get(0).getCoordonneesJoueur());
            System.out.println("this.ListeJoueurReseau.get(1).getCoordonneesJoueur()");
            System.out.println(this.ListeJoueurReseau.get(1).getCoordonneesJoueur());
            this.p.MiseAJourAutreJoueur(this.ListeJoueurReseau); // argument pb
            this.p.Gestiondeplacement();
            this.p.MiseAJourJoueur();
            // méthode réseau 
            Dessin.instance.sql.UpdatedCoord(this.ListeJoueurReseau.get(0));
            this.jLabel1.repaint();
            this.p.Afficher(contexteBuffer);
            //this.p.tracerLine(contexteBuffer);
         }
       //}
        //event2 = true;
        }
   
 
    @Override
    public void keyTyped(KeyEvent e) {
       //NOP
    }

    
    
     @Override
    public void keyPressed(KeyEvent evt) {
        if (evt.getKeyCode() == evt.VK_RIGHT) {
            this.p.setDroite(true);
            this.p.setGauche(false); 
            this.p.setUp(false);  
            this.p.setDown(false);
            
          //  this.jeu.tracerLine(contexteBuffer);

           // this.jeu.tracerLine(contexteBuffer);
        }
        if (evt.getKeyCode() == evt.VK_LEFT) {
           this.p.setDroite(false);
           this.p.setGauche(true); 
           this.p.setUp(false);  
           this.p.setDown(false);
           
           // this.jeu.tracerLine(contexteBuffer);

            
        }
        if(evt.getKeyCode()== evt.VK_UP){
             this.p.setDroite(false);
             this.p.setGauche(false); 
             this.p.setUp(true);  
             this.p.setDown(false);
           
           // this.jeu.tracerLine(contexteBuffer);

             
        }
        if(evt.getKeyCode()==evt.VK_DOWN){
             this.p.setDroite(false);
             this.p.setGauche(false); 
             this.p.setUp(false);  
             this.p.setDown(true);
            
            //this.jeu.tracerLine(contexteBuffer);

        if((evt.getKeyCode()==evt.VK_DOWN)&&(evt.getKeyCode()==evt.VK_LEFT)){
             this.p.setDroite(false);
             this.p.setGauche(true); 
             this.p.setUp(false);  
             this.p.setDown(true);
        }
        } 
    }

    @Override
    public void keyReleased(KeyEvent evt) {
         if (evt.getKeyCode() == evt.VK_RIGHT) {
             this.p.setDroite(true);
             this.p.setGauche(false); 
             this.p.setUp(false);  
             this.p.setDown(false);
        }
        if (evt.getKeyCode() == evt.VK_LEFT) {
            this.p.setDroite(false);
             this.p.setGauche(true); 
             this.p.setUp(false);  
             this.p.setDown(false);
        }
        if(evt.getKeyCode()== evt.VK_UP){
            this.p.setDroite(false);
             this.p.setGauche(false); 
             this.p.setUp(true);  
             this.p.setDown(false);
        }
        if(evt.getKeyCode()==evt.VK_DOWN){
           this.p.setDroite(false);
             this.p.setGauche(false); 
             this.p.setUp(false);  
             this.p.setDown(true);
        }
    }
    
   public void paint(Graphics g) {
        super.paint(g);
        
        BufferedImage tileSet = null;
        try {
            tileSet = ImageIO.read(new File("tileSetMinecraft32x32.png"));
        } catch (IOException ex) {
            Logger.getLogger(Dessin.class.getName()).log(Level.SEVERE, null, ex);
        }
          int map[][] ={ {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 }, 
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },    // dessin d'une carte
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 70,    70, 134,  134, 70,   134,   70,  134,  74, 74,  74,  134,  76, 76,  76,  134, 78,  134,  78, 134, 134, 134 },
                         {134, 134, 134, 70,   134,  70,  134, 70,   134,   70,  134,  74, 134, 74,  134,  76, 134, 76,  134, 78,  134,  78, 134, 134, 134 },
                         {134, 134, 134, 70,    70, 134,  134, 70,    70,   70,  134,  74, 74, 74,  134,  76, 76, 134,  134, 134, 78,  134, 134, 134, 134 },
                         {134, 134, 134, 70,   134,  70,  134, 70,   134,   70,  134,  74, 134, 74,  134,  76, 134, 76,  134, 134, 78,  134, 134, 134, 134 },
                         {134, 134, 134, 70,    70, 134,  134, 70,   134,   70,  134,  74, 134, 74,  134,  76, 134, 76,  134, 134, 78,  134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                         {134, 134, 134, 134,  134, 134,  134, 134,  134,  134,  134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134 },
                  
            // int map[][];
           //  map=new int[19][25];
           //   for(int i=0;i<19;i++){
           //       for(int j=0;j<25;j++){
            //       map[i][j] = 134;
              //  }
             // }        
        };
        
//         FenetreGraphique contexteBufferMap = new FenetreGraphique("Hello World!", 40 * TILE_WIDTH, 20 * TILE_HEIGHT);//peut etre non
//         contexteBufferMap.effacer(new Color(175, 226, 255));//peut etre non
        

//        Graphics2D contexte = contexteBufferMap.getGraphics2D();// changer la fenetre par le jlabell (affecter au label)
     for (int y=0; y<map.length; y++){       // une boucle qui permet de créer un tableau de (un nombre) de tuiles contenant des tuiles different... et qui genere des tuiles....
         for(int x =0;x<map[y].length;x++){
        
        int tileNumber = map[y][x];
        int tileX = (tileNumber % TILES_PER_ROW) * TILE_WIDTH;
        int tileY = (tileNumber / TILES_PER_ROW) * TILE_HEIGHT;
        BufferedImage tile = tileSet.getSubimage(tileX, tileY, TILE_WIDTH, TILE_HEIGHT);// subimag: on prend juste une partie du tile;

    
        contexteBuffer.drawImage(tile, x*32, y*32, null); //on multiple x et y (les coordonnées de tile) par*32 pour les convertir du coordonnées vers des pixels
         }
     }
//     System.out.println("tilemap");
//        
//        contexte.drawImage(tile, 130, 130, null);
//        contexte.drawImage(tile, 200, 200, null);
       
  
        //this.repaint();
      //  System.out.println("ok");
        //this.repaint();
      //  this.jPanel1.repaint();
//        this.jLabel3.repaint();
//       avatar.repaint();
          
        }  
  

}